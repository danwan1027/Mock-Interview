/* tslint:disable */
/* eslint-disable */
/**
 * Streaming Avatar SDK
 * Heygen Streaming Avatar
 *
 * The version of the OpenAPI document: 1.0.4
 * Contact: api@heygen.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
    IceRequest,
    IceResponse,
    InterruptRequest,
    InterruptResponse,
    NewSessionData,
    NewSessionIceServers2,
    NewSessionRequest,
    NewSessionResponse,
    Sdp,
    StartSessionRequest,
    StartSessionResponse,
    StopSessionRequest,
    StopSessionResponse,
    TaskRequest,
    TaskResponse,
} from '../models/index';
import {
    IceRequestFromJSON,
    IceRequestToJSON,
    IceResponseFromJSON,
    IceResponseToJSON,
    InterruptRequestFromJSON,
    InterruptRequestToJSON,
    InterruptResponseFromJSON,
    InterruptResponseToJSON,
    NewSessionRequestFromJSON,
    NewSessionRequestToJSON,
    NewSessionResponseFromJSON,
    NewSessionResponseToJSON,
    StartSessionRequestFromJSON,
    StartSessionRequestToJSON,
    StartSessionResponseFromJSON,
    StartSessionResponseToJSON,
    StopSessionRequestFromJSON,
    StopSessionRequestToJSON,
    StopSessionResponseFromJSON,
    StopSessionResponseToJSON,
    TaskRequestFromJSON,
    TaskRequestToJSON,
    TaskResponseFromJSON,
    TaskResponseToJSON,
} from '../models/index';
import { parseEvent } from '../events/utils';
import { EventMap, EventType } from '../events/events';

export interface CreateStreamingAvatarRequest {
    newSessionRequest: NewSessionRequest;
}

export interface InterruptOperationRequest {
    interruptRequest: InterruptRequest;
}

export interface SpeakRequest {
    taskRequest: TaskRequest;
}

export interface StartStreamingAvatarRequest {
    startSessionRequest: StartSessionRequest;
}

export interface StopSessionOperationRequest {
    stopSessionRequest: StopSessionRequest;
}

export interface SubmitICECandidateRequest {
    iceRequest: IceRequest;
}

/**
 * 
 */
export class StreamingAvatarApi extends runtime.BaseAPI {

    private eventSystem: EventTarget = new EventTarget();
    private listenerMap: Map<EventType, Map<(detailData: any) => any, (ev: CustomEvent) => any>> = new Map();

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Opens and returns a new streaming avatar session
     */
    async createStreamingAvatarRaw(requestParameters: CreateStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NewSessionResponse>> {
        if (requestParameters['newSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'newSessionRequest',
                'Required parameter "newSessionRequest" was null or undefined when calling createStreamingAvatar().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.new`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: NewSessionRequestToJSON(requestParameters['newSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NewSessionResponseFromJSON(jsonValue));
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Opens and returns a new streaming avatar session
     */
    async createStreamingAvatar(requestParameters: CreateStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NewSessionResponse> {
        const response = await this.createStreamingAvatarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Interrupt the current Streaming
     */
    async interruptRaw(requestParameters: InterruptOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InterruptResponse>> {
        if (requestParameters['interruptRequest'] == null) {
            throw new runtime.RequiredError(
                'interruptRequest',
                'Required parameter "interruptRequest" was null or undefined when calling interrupt().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.interrupt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InterruptRequestToJSON(requestParameters['interruptRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InterruptResponseFromJSON(jsonValue));
    }

    /**
     * Interrupt the current Streaming
     */
    async interrupt(requestParameters: InterruptOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InterruptResponse> {
        const response = await this.interruptRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pass text to be repeated by avatar
     */
    async speakRaw(requestParameters: SpeakRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TaskResponse>> {
        if (requestParameters['taskRequest'] == null) {
            throw new runtime.RequiredError(
                'taskRequest',
                'Required parameter "taskRequest" was null or undefined when calling speak().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.task`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TaskRequestToJSON(requestParameters['taskRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TaskResponseFromJSON(jsonValue));
    }

    /**
     * Pass text to be repeated by avatar
     */
    async speak(requestParameters: SpeakRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TaskResponse> {
        const response = await this.speakRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Starts the streaming avatar session. Must be called after creation.
     */
    async startStreamingAvatarRaw(requestParameters: StartStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StartSessionResponse>> {
        if (requestParameters['startSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'startSessionRequest',
                'Required parameter "startSessionRequest" was null or undefined when calling startStreamingAvatar().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.start`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StartSessionRequestToJSON(requestParameters['startSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StartSessionResponseFromJSON(jsonValue));
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Starts the streaming avatar session. Must be called after creation.
     */
    async startStreamingAvatar(requestParameters: StartStreamingAvatarRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StartSessionResponse> {
        const response = await this.startStreamingAvatarRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stops the streaming avatar session. This endpoint has been exposed to support advanced applications. To ensure the RTC session is correctly closed, please use stopAvatar instead.
     */
    async stopSessionRaw(requestParameters: StopSessionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<StopSessionResponse>> {
        if (requestParameters['stopSessionRequest'] == null) {
            throw new runtime.RequiredError(
                'stopSessionRequest',
                'Required parameter "stopSessionRequest" was null or undefined when calling stopSession().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.stop`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StopSessionRequestToJSON(requestParameters['stopSessionRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => StopSessionResponseFromJSON(jsonValue));
    }

    /**
     * Stops the streaming avatar session. This endpoint has been exposed to support advanced applications. To ensure the RTC session is correctly closed, please use stopAvatar instead.
     */
    async stopSession(requestParameters: StopSessionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<StopSessionResponse> {
        const response = await this.stopSessionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Submit the ICE candidate. Dependent on active session.
     */
    async submitICECandidateRaw(requestParameters: SubmitICECandidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IceResponse>> {
        if (requestParameters['iceRequest'] == null) {
            throw new runtime.RequiredError(
                'iceRequest',
                'Required parameter "iceRequest" was null or undefined when calling submitICECandidate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("bearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/v1/streaming.ice`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IceRequestToJSON(requestParameters['iceRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IceResponseFromJSON(jsonValue));
    }

    /**
     * This call is encapsulated by createAndStartAvatar, only use this for advanced applications
     * Submit the ICE candidate. Dependent on active session.
     */
    async submitICECandidate(requestParameters: SubmitICECandidateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IceResponse> {
        const response = await this.submitICECandidateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * This call both terminates the streaming avatar session and closes the RTC connection
     */
    async stopAvatar(requestParameters: StopSessionOperationRequest, debugStream?: (string) => void, initOverrides?: RequestInit | runtime.InitOverrideFunction) {
        if (this.peerConnection) {
            this.peerConnection.close();
        }

        const debug = new Debug(debugStream);
        await this.stopSession(requestParameters.stopSessionRequest.sessionId ? requestParameters : {
            stopSessionRequest: { sessionId: this.sessionId ?? "" }
        }, initOverrides).catch((error) => {
            debug.print(JSON.stringify(error));
        });
        debug.print("Stopped session successfully.")
    }

    /**
     * This call creates and starts a new streaming avatar session
     */
    async createStartAvatar(requestParameters: CreateStreamingAvatarRequest, debugStream?: (string) => void, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NewSessionData> {
        const convertToRTCIceServer = (iceServers: NewSessionIceServers2[]) => {
            const rtcs: RTCIceServer[] = [];
            iceServers.forEach(server => {
                const rtc = {
                    urls: server.urls,
                    username: server.username,
                    credential: server.credential
                }
                rtcs.push(rtc);
            });
            return rtcs;
        }

        const convertToRTCSessionDescription = (serverSdp: Sdp) => {
            return new RTCSessionDescription({ sdp: serverSdp.sdp, type: serverSdp.type as RTCSdpType })
        }

        const debug = new Debug(debugStream);

        const onMessage = (event) => {
            const message = event.data;
            if (message instanceof ArrayBuffer) {
                const messageString = new TextDecoder().decode(message);
                debug.print(`Received event: ${messageString}`);
                // convert data to JSON
                const eventMsg = parseEvent(messageString);
                if (eventMsg != null) {
                    this.eventSystem.dispatchEvent(eventMsg);
                }
            } else {
                debug.print(`STREAMING AVATAR: Received message: ${message}`);
            }
        }

        try {
            debug.print("Creating a new session...");

            const { data } = await this.createStreamingAvatar(requestParameters, initOverrides);
            const { sdp: serverSdp, iceServers2: iceServers } = data;
            this.sessionId = data.sessionId;

            this.peerConnection = new RTCPeerConnection({ iceServers: convertToRTCIceServer(iceServers) });

            this.peerConnection.ontrack = (event) => {

                if (event.track.kind === 'audio' || event.track.kind == 'video') {
                    this._mediaStream = event.streams[0];
                }
            }

            // When receiving a message, display it in the status element
            this.peerConnection.ondatachannel = (event) => {
                const dataChannel = event.channel;
                dataChannel.onmessage = onMessage;
            };

            // Set server's SDP as remote description
            const remoteDescription = new RTCSessionDescription(convertToRTCSessionDescription(serverSdp));
            await this.peerConnection.setRemoteDescription(remoteDescription);

            debug.print("Session creation complete.");

            if (!data) {
                throw Error("STREAMING AVATAR: Issue with created session");
            }

            debug.print("Starting the session...");
            const localDescription = await this.peerConnection.createAnswer();
            await this.peerConnection.setLocalDescription(localDescription);

            this.peerConnection.onicecandidate = async ({ candidate }) => {
                if (candidate) {
                    this.submitICECandidate({ iceRequest: { sessionId: this.sessionId, candidate: { candidate: candidate.candidate, sdpMid: candidate.sdpMid, sdpMLineIndex: candidate.sdpMLineIndex, usernameFragment: candidate.usernameFragment } } })
                        .then(async (c) => {
                            // When ICE connection state changes, display the new state
                            this.peerConnection.oniceconnectionstatechange = (_event) => {
                                debugStream(`ICE connection state changed to: ${this.peerConnection.iceConnectionState}`);
                            };
                        }
                        ).catch(error => {
                            debug.print(JSON.stringify(error));
                        });
                }
            };

            await this.startStreamingAvatar({ startSessionRequest: { sdp: localDescription, sessionId: this.sessionId } });

            // Set jitter buffer
            if (this.configuration.jitterBuffer !== undefined) {
                let receivers = this.peerConnection.getReceivers();


                receivers.forEach(receiver => {
                    if ('jitterBufferTarget' in receiver) {
                        receiver.jitterBufferTarget = this.configuration.jitterBuffer;
                    }
                });
            }

            debug.print("Session started successfully");

            return data;
        } catch (error) {
            this.peerConnection.close();
        }

    }

    addEventHandler<K extends EventType>(event: K, listener: (data: any) => any) {
        let newListener = (customEv: CustomEvent) => {
            if (customEv.detail.type === event) {
                listener(customEv.detail);
            }
        }

        if (!this.listenerMap.has(event)) {
            this.listenerMap.set(event, new Map());
        }
        this.listenerMap.get(event)!.set(listener, newListener);

        this.eventSystem.addEventListener(event, newListener);
    }

    removeEventHandler<K extends EventType>(event: K, listener: (data: any) => any) {
        const eventListeners = this.listenerMap.get(event);
        if (eventListeners) {
            const newListener = eventListeners.get(listener);
            if (newListener) {
                this.eventSystem.removeEventListener(event, newListener);
                eventListeners.delete(listener);
                if (eventListeners.size === 0) {
                    this.listenerMap.delete(event);
                }
            }
        }
    }

    get mediaStream() {
        return this._mediaStream;
    }

}


class Debug {
    private _debug: (text: string) => void;

    constructor(debug?: (text: string) => void) {
        this._debug = debug;
    }

    print(text: string) {
        if (!this._debug) {
            return;
        }

        this._debug(text);
    }
}
