"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fixOpenAPI = void 0;
const const_1 = require("./const");
function fixOpenAPI(data) {
    fixTag(data);
    fixUniqueTagOperation(data);
}
exports.fixOpenAPI = fixOpenAPI;
function fixTag(data) {
    const { tags, paths } = data;
    const finalNameMap = {};
    Object.keys(paths).forEach(path => {
        const pathItemObject = paths[path];
        Object.keys(pathItemObject).forEach(method => {
            const operation = pathItemObject[method];
            if (!Array.isArray(operation.tags) || !operation.tags.length) {
                operation.tags = ['Default'];
            }
            operation.tags = operation.tags.map(tagName => {
                if (finalNameMap[tagName]) {
                    return finalNameMap[tagName];
                }
                let tagObject = tags.find(t => t.name === tagName);
                if (!tagObject) {
                    tagObject = {
                        name: tagName,
                        description: tagName,
                    };
                    tags.push(tagObject);
                }
                if (!const_1.testTypeNameValid(tagObject.name)) {
                    const description = (tagObject.description || tagObject.name)
                        .replace(/ /g, '')
                        .replace(/[\-\,\.\/]/g, '_');
                    const newName = const_1.testTypeNameValid(description) ? description : 'UNKNOWN';
                    tagObject.description = tagObject.name;
                    return (tagObject.name = finalNameMap[tagObject.name] = newName);
                }
                else {
                    return (finalNameMap[tagObject.name] = tagObject.name);
                }
            });
        });
    });
}
function fixUniqueTagOperation(data) {
    const { paths } = data;
    const tagOpNameCounter = {};
    Object.keys(paths).forEach(path => {
        const pathItemObject = paths[path];
        [
            pathItemObject.get,
            pathItemObject.put,
            pathItemObject.post,
            pathItemObject.delete,
            pathItemObject.options,
            pathItemObject.head,
            pathItemObject.patch,
            pathItemObject.trace,
        ]
            .filter(o => o)
            .forEach(operation => {
            operation.tags.forEach(tag => {
                const key = `${tag}.${operation.operationId}`;
                if (tagOpNameCounter[key]) {
                    operation.operationId += `_${tagOpNameCounter[key]++}`;
                }
                else {
                    tagOpNameCounter[key] = 1;
                }
            });
        });
    });
}
